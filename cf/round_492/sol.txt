2A，2B略
A：
给定一个4 * n(n <= 50)的停车场，你需要把k<=2*n 辆车丢到他们应该在的编号里面, 输出方案或者-1。
第一行第四行是车位，2，3行是还没停进去的车。
思路：-1就是 k == 2 * n的时候，假设我们转了一圈他都是错位的，那我们不能移动，无解，否则我们都可以直接在第2，3行转圈，能停就停。
B:
2n个数,1~n各出现2次
每次可以交换相邻的数字
问几次能让每个数出现的两次是连续的
暴力换，n太小了。。
C：
N个长度小于等于1e6的向量，你可以把它*1或者*-1，然后让你搞一个长度小于1.5*10^6的向量，输出搞的时候每个向量的系数是1/-1

乱做做法：首先有个很显然虽然不太对的贪心，你想要最后的向量尽量短，所以顺着扫，看看加入新的之后是直接加长度小还是取反加长度小，选小的那个。
然后乱做就乱做在这个过程做一遍是显然错误的，但是每次random shuffle一下若干次就对了。

标准做法：
对于三个任意向量，这三个向量或者他们的反向量肯定是能搞出一对夹角>=120的向量，这样把这两个并起来搞不大所得的向量。

D：
A和B玩游戏，在填一个n位的二进制数, 每次随机一个人过来选一位填成0或者1
最后得分是c[二进制数数值]
A要让它尽量大,B要让它尽量小
问期望得到的值是多少,然后接下来r次修改
每次修改c数组里面一个数的值,然后再询问
n<=18
r<=2^18

Qls：结论结论，sum(c) / (1 << n)， 证明显然
我们：？？？？？？
然后看了std的证明，有那么一屁股道理

E ：
思路在我读题之前被剧透了，折半考虑。
题意：A在手机上点击数字（什么垃圾翻译），他从整数u开始，每秒钟他都可以搞下面3种操作之一
①	u->(u + 1) % p;
②	u->(u – 1 + p) % p
③	u->(u ^ (p - 2)) % p 
他想200下或者更少来得到一个数v，问怎么搞。
 P >= 3 && P <= 1e9 + 9, u, v <= P – 1;

Sol 1: 搞出根号n条随机路径，然后看看有没有交点，如果有的话就是那个路径。正确性我也不会证明，就会证个复杂度（23333）
Sol 2：从u开始bfs，然后从v开始bfs，如果能meet，那就输出那路径，这个能证明23333.

F：
题意：给一个n(n <= 3000)个节点的有根树（应该是），然后一个节点的儿子的值是小于等于该节点值的正整数，所有点的值都是<=D（D 1e9）的，问你能搞出几种方案。

打比赛长见识系列，这个题拉格朗日插值做。

首先有个最基本的点，就是直接n*D的dp， dp[i][j]表示以i为根，j是i所选的值的方案数，直接从儿子往爸爸上并。但是这是个F。。。这样要是能过有点日狗。

然后我们的dp就变成了节点i，expj的系数。
拉格朗日插值的话我们可以对于 d <= n, 直接n * n 的dp算，d > n && d <= D 插出来。然后不太会，但是问题不是很大，会扣就行（误），其实是在准备期末没那么多时间弄懂，先拖板子，mark下来，但是我们先知道有这么个东西可以搞出来这个。

然后这样的话，对于这个来说，把他看成多项式，他肯定是每个值都能取得到的，所以就是个和D项n阶多项式。
那么单独考虑一个父亲和儿子，设poly(i)是儿子得到i的方案数，初始化肯定是儿子是几就是几，比如儿子是x + 2 * x ^ 2, poly也长这样，那么考虑还有什么方法可以得到i，就是Σ0to (i-1)，理解起来就是他的值是几，他的儿子的值小于等于他的都能把他搞出来。
那这样就直接预处理一个前缀和，爸爸的方案数就是儿子给的每一项的系数的乘积。
然后拉格朗日。

